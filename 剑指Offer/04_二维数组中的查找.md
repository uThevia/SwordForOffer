## 04\_二维数组中的查找
`Q04_FindNumberInTwoDArray`

在一个 n * m 的二维数组中，每一行都按照从左到右 **非递减** 的顺序排序，每一列都按照从上到下 **非递减** 的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例:
现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```
给定 target = `5`，返回 `true`。
给定 target = `20`，返回 `false`。

限制：
```
0 <= n <= 1000
0 <= m <= 1000
```

**思路**
由于大小是对称的, 先仅考虑大于
简单
直接查找 O(mn)
二分查找 O(nlogm)
	对每一行二分查找

Z字形查找 O(m+n)
从中间开始找 每一步有3种可能: 当前, 向右, 向下. 这样后两种会有重叠
从右上角开始找 如果小于则删除列, 如果大于则删除行

#### M1 Z字形查找

从右上角开始找 如果小于则向左, 如果大于则向下
递增矩阵(二维数组)的边界是从左下到右上的 寻找某个数应当从一个角开始蛇形前进 直到出界为止(不一定到左下角)

```java
boolean solution(int[][] matrix, int num) {
    int m = matrix.length;      // 行数
    int n = matrix[0].length;   // 列数

    // 当前坐标 (row, column)
    // 从右上角开始
    int row = 0;
    int column = n - 1;

    int temp = 0;
    while (row < m && column >= 0) {   // 未出界
        temp = matrix[row][column];
        if (temp == num)
            return true;
        else if (temp < num)
            row += 1;
        else
            column -= 1;
    }
    return false;
}
```



- 可视化理解

将矩阵逆时针旋转 45°，并转化为图形式，发现其类似于 二叉搜索树，即对于每个元素，其左分支元素更小、右分支元素更大。
因此，通过从"根节点"开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target

![Picture1.png](assets/04_%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png)