## 12_矩阵中的路径

`Q12_PathInMatrix`

给定一个 m x n 二维字符矩阵网格 board 和一个长度为L的字符串单词 word 。仅当 word 存在于网格中返回 true 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中"相邻"单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

限制
1 <= m, n <= 6
1 <= L <= 15
board 和 word 仅由大小写英文字母组成

示例:
例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"

![img](assets/12_%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/word2.jpg)


**思路**
简单
同时判断正序和倒序词
起始点依次选定 延伸依次顺时针判定3个方向 路径用逻辑矩阵记录

回溯法
函数check(i,j,k)判断从点(i,j)出发能否搜到word[k:]
	已到字符串结尾: k=word.length 返回true
	剪枝 判断当前点: board[i][j]≠word[k] 返回false
	遍历当前点的相邻位置 递归check(相邻点坐标,k+1) 
		回溯 相邻位都不满足则回溯当前点
起始为check(i,j,0), (i,j)为遍历board所有点
需要标记访问数组visited记录某点是否属于当前路径 与board等大

复杂度分析
时间 非常宽松上界O(mn3^L)
	遍历board所有点为mn, 每个点找下个点至多3个分支为3^L
	实际上远小于 因为有检查当前点的剪枝
空间 O(mn) 标记访问数组; 栈深度最大O(min(L,mn)

### M


**举一反三**

**总结**